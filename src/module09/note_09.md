#### 异常 : 00

```
结构化程序设计的三大特性：顺序执行、分支执行、循环执行

异常的概念：
    程序在运行的过程中可能产生异常
    异常(Exception)与Bug的区别
        异常时程序运行时可预料的执行分支
        Bug是程序中的错误，是不被预期的运行方式

异常(Exception)和Bug的对比
    异常
        运行时产生除0的情况
        需要打开的外部文件不存在
        数组访问时越界
    Bug
        使用野指针
        堆数组使用结束后未释放
        选择排序无法处理长度为0的数组

小结：
    程序中不可避免的会发生异常
    异常是在开发阶段就可以预见的运行时问题
    C语言中通过经典的if...else...方式处理异常
    C++中存在更好的异常处理方式
```

#### 异常 : 01、02

```
C++内置了异常处理的语法元素try...catch...
    try语句处理正常代码逻辑
    catch语句处理异常情况
    try语句中的异常由对应的catch语句处理

C++异常处理分析
    throw抛出的异常必须被catch处理
        当前函数能够处理异常，程序继续往下执行
        当前函数无法处理异常，则函数停止执行，并返回

未被处理的的异常会顺着函数调用栈向上传播，直到被处理为止，否则程序将停止执行

同一个try语句可以跟上多个catch语句
    catch语句可以定义具体处理的异常类型
    不同类型的异常由不同的catch语句负责处理
    try语句中可以抛出任何类型的异常
    catch(...)用于处理所有类型的异常
    任何异常都只能被捕获(catch)一次

异常处理的匹配规则
    异常抛出后，自上而下严格匹配每一个catch语句处理的类型
    异常处理匹配时，不进行任何的类型转换

小结：
    C++中直接支持异常处理的概念
    try...catch...是C++中异常处理的专用语句
    try语句处理正常代码逻辑，catch语句处理异常处理
    同一个try语句可以跟上多个catch语句
    异常处理必须严格匹配，不进行任何的类型转换
```

#### 异常 : 03

```
catch中捕获的异常可以被重新解释后抛出

异常的类型可以是自定义类型
对于类类型异常的匹配以就是自上而下严格匹配
赋值兼容性原则在异常匹配中依然适用
一般而言
    匹配子类异常的catch放在上部
    匹配父类异常的catch放在下部

工程中会定义一系列的异常类
每个类代表工程中可能出现的一种异常类型
代码复用时可能需要重解释不同的异常类
在定义catch语句块时推荐使用引用(&)作为参数

C++标准库中提供了实用异常类族
标准库中的异常都是从exception类派生的
exception类有两个主要的分支
    logic_error
        常用于程序中的可避免逻辑错误
    runtime_error
        常用于程序中无法避免的恶性错误

小结：
    catch语句块中可以抛出异常
    异常的类型可以是自定义类类型
    赋值兼容性原则在异常匹配中依然适用
    标准库中的异常都是从exception类派生的
```

#### 类型识别 : 04、05

```
利用继承间的多态性，实现类型函数以判定并正确的进行类型对象转换

在面向对象中可能出现下面的情况
    基类指针指向子类对象
    基类引用成为子类对象的别名

Base* p = new Derived();
Base& r = *p;
静态类型    动态类型

静态类型 - 变量(对象)自身的类型
动态类型 - 指针(引用)所指向的对象的实际类型

基类指针是否可以强制类型转换为子类指针，取决于动态类型

解决方案 - 利用多态(动态类型识别)
    1、在基类中定义虚函数返回具体的类型信息
    2、所有的派生类都必须实现类型相关的虚函数
    3、每个类中的类型虚函数都需要不同的实现

多态解决方案的缺陷
    必须从基类开始提供类型虚函数
    所有的派生类都必须重写类型虚函数
    每个派生类的类型名必须唯一

C++提供了typeid关键字用于获取类型信息
    typeid关键字返回对应参数的类型信息
    typeid返回一个type_info类对象
    当typeid的参数为NULL时将抛出异常

typeid的注意事项
    当参数为类型时：返回静态类型信息
    当参数为变量时：
        不存在虚函数表，返回静态类型信息
        存在虚函数表，返回动态类型信息
    typeid在不同的编译器下拥有不用的行为输出，所以不要使用typeid的返回结果进行判定

小结：
    C+++中有静态类型和动态类型的概念
    利用多态能够实现对象的动态类型识别
    typeid时专用于类型识别的关键字
    typeid能够返回对象的动态类型信息
```

#### 指针判断 : 06、07

```
C++中仍然支持C语言中的可变参数函数
C++编译器的匹配优先级
    1、重载函数
    2、函数模板
    3、可变参函数

检查a.out执行是否有内存泄漏命令
    valgrind --tool=memcheck --leak-check=full ./a.out

构造函数中抛出异常
    构造过程立即停止
    当前对象无法生成
    析构函数不会被调用
    对象所占用的空间立即收回

小结：
    C++中依然支持可变参函数
    可变参函数无法很好的处理对象参数
    利用函数模板和可变参函数能够判断指针变量
    构造函数和析构函数中不要抛出异常
```

####  泛指类型声明: 08

```
class和typename都可以用来声明泛型变量
typename的作用：
    1、在模板定义中声明泛指类型
    2、明确告诉编译器其后的标识符为类型
```

####  函数与异常: 09

```
try...catch用于分隔正常功能代码与异常处理代码
try...catch可以直接将函数实现分隔为2部分
函数声明和定义时可以直接指定可能抛出的异常类型
异常声明成为函数的一部分可以提高代码可读性

注意事项
    函数异常声明是一种与编译器之间的契约
    函数声明异常后就只能抛出声明的异常
        抛出其它异常将导致程序运行终止
        可以直接通过异常声明定义无异常函数

小结：
    class可以用来在模板中定义泛指类型(不推荐)
    typename是可以消除模板中的二义性
    try...catch可以将函数体分为2部分
    异常声明能够提供程序的可读性
```