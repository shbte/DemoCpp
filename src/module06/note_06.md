#### 继承概念 : 00

```
继承是面向对象中类之间的一种关系
子类拥有父类的所有属性和行为
子类对象可以当作父类对象使用
子类中可以添加父类没有的方法和属性
继承是面向对象中代码复用的重要手段
```

#### 继承访问级别 : 01

```
C++中支持三种不同的继承方式,默认继承方式为private
    public继承
        父类成员在子类中保持原有访问级别
    private继承
        父类成员在子类中变为私有成员
    protected继承
        父类中的公有成员变为保护成员,其它成员保持不变

面向对象中的访问级别不只是public和private
protected修饰的成员不能被外界所访问
protected使得子类能够访问父类的成员
protected关键字是为了继承而专门设计的
没有protected就无法完成真正意义上的代码复用
```

#### 继承之构造与析构 : 02

```
子类对象在创建时需要调用父类构造函数进行初始化
先执行父类构造函数，然后执行成员的构造函数
父类构造函数显式调用需要在初始化列表中进行
子类对象在销毁时需要调用父类析构函数进行清理
析构顺序与构造函数对称相反
```

#### 继承之同名变量和函数 : 03

```
成员
    子类可以定义父类中的同名成员
    子类中的成员将隐藏父类中的同名成员
    父类中的同名成员依然存在于子类中
    通过作用域分辨符(::)访问父类中的同名成员

成员函数
    子类中的函数将隐藏父类的同名函数
    子类无法重载父类中的成员函数(因为作用与不同，不构成重载)
    使用作用域分辨符访问父类中的同名函数
    子类可以定义父类中完全相同的成员函数(因为作用与不同，不构成冲突)
    子类可以重定义父类中已经存在的成员函数
    这种重定义发生在继承中，叫做函数重写
    函数重写时同名覆盖的一种特殊情况

tip:
子类存在和父类同名函数时，子类匹配不到函数也不会去父类匹配
子类分为子类的子类对象和子类的父类对象
    Parent p0 = c0; // 这是将子类c0的父类对象调用父类的拷贝构造函数创建新父类对象p0
```

#### 父类与子类的相互转换 : 04

```
子类对象可以当作父类对象使用(兼容性)
    子类对象可以直接赋值给父类对象
    子类对象可以直接初始化父类对象
    父类指针可以直接指向子类对象
    父类引用可以直接引用子类对象

当使用父类指针(引用)指向子类对象时
    子类对象退化为父类对象
    只能访问父类中定义的成员
    可以直接访问被子类覆盖的同名成员
```

#### 父类与子类之重写、多态 : 05

```
函数重写只可能发生在父类与子类之间
根据实际对象的类型确定调用的具体函数
virtual关键字时C++中支持多态的唯一方式
被重写的虚函数可表现出多态的特征

理论中的概念
    静态联编
        在程序的编译期间就能确定具体的函数调用
        如：函数重载
    动态联编
        在程序实际运行后才能确定具体的函数调用
        如：函数重写
```

#### 类与结构体 : 06

```
运行时的对象退化为结构体的形式
    所有成员变量在内存中依次排布
    成员变量间可能存在内存空隙(内存对齐)
    可以通过内存地址直接访问成员变量(p->i)
    访问权限关键字在运行时失效(编译时有效，编译完后变成二进制就没有访问权限的概念了，可以通过指针和内存地址修改成员变量的值)

类中的成员函数位于代码段中
调用成员函数时对象地址作为参数隐式传递(因为成员函数属于类，不属于对象，函数通过传递过来的this进行区分调用对象)
成员函数通过对象地址访问成员变量
C++语法规则隐藏了对象地址的传递过程(this)

小结：
    C++中的类对象在内存布局上与结构体相同
    成员变量和成员函数在内存中分开存放
    访问权限关键字在运行时失效
    调用成员函数时对象地址作为参数隐式传递
```

#### 父类与子类之多态 : 07

```
C++多态的实现原理
    当类中声明虚函数时，编译器会在类中生成一个虚函数表
    虚函数表是一个存储成员函数地址的数据结构
    虚函数表是由编译器自动生成与维护的
    irtual成员函数会被编译器放入虚函数表中
    存在虚函数时，每个对象中都有一个指向虚函数表的指针

调用效率: 虚函数 < 普通成员函数
    p => (具体对象 | VPTR) => (VTABLE | void (*pADD)(int value)) => (0xFF010203)

小结：
    继承的本质就是父子间成员变量的叠加
    C++中的多态是通过虚函数表实现的
    虚函数表时是由编译器自动生成与维护的
    虚函数的调用效率低于普通成员函数
    面向对象的三大特性：封装、继承、多态
```
