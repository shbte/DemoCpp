#### 抽象类 && 纯虚函数 : 00

```
抽象类和村纯虚函数

    C++语言中没有抽象类的概念

    C++中通过纯虚函数实现抽象类

    纯虚函数是指只定义原型的成员函数

    一个C++类中存在纯虚函数就成为了抽象类

语法规则
    class Shape
    {
        public:
            virtual double area() = 0;
    }

"=0"用于告诉编译器当前是声明纯虚函数，因此不需要定义函数体。

注意事项：

    抽象类只能定义为父类，只能用作父类被继承

    子类必须实现纯虚函数的具体功能

    纯虚函数被实现后成为虚函数

    如果子类没有实现纯虚函数，则子类成为抽象类

接口(满足下面条件的C++类则称为接口)：

    类中没有定义任何的成员变量

    所有的成员函数都是公有的

    所有的成员函数都是纯虚函数

    接口是一种特殊的抽象类

小结：

    抽象类用于描述现实世界中的抽象概念

    抽象类只能被继承不能创建对象

    C++中没有抽象类的概念

    C++中通过纯虚函数实现抽象类

    类中只存在纯虚函数时成为接口

    接口是一种特殊的抽象类
```

#### 多重继承 : 01、02、03

```
多重继承

    子类将拥有子类所有成员，利用sizeof(Child)来判断

多重继承(子类有不止一个父类)，即子类中有不止一个虚函数表指针

强制类型转换，但是指针指向还是原来的，并没有进行修正

    BaseB *pba = (BaseB *)pa;

dynamic_case<type>类型转换，会对指针值进行修正，指针指向转换后类型

    BaseB *pbb = dynamic_cast<BaseB *>(pa);

工程开发中的“多重继承”方式：

    单继承某个类 + 实现(多个)接口

一些有用的工程建议

    先继承自一个父类，然后实现多个接口

    父类中提供equal()成员函数，用于判断当前指针是否指向当前对象(所定义的类对象)

    与多重继承相关的强制类型转换用dynamic_cast完成

小结：

    多继承中可能出现多个虚函数表指针

    与多重继承相关的强制类型转换用dynamic_cast完成

    工程开发中采用“单继承多接口”的方式使用多继承

    父类提供成员函数用于判断指针是否指向当前对象

tip：

    方法返回值为对象时，方法外还可以使用n次，并不会离开作用域而被释放

    方法返回值为对象指针时，方法外还可以使用1次，然后因离开作用域而被释放

    父类不能转换为子类

    子类没有自己的虚函数表指针，子类中的虚函数表指针都是父类的
```

#### 补充 : 04、05、06

```
new关键字与malloc函数的区别

    new关键字是C++的一部分

    malloc是由C库提供的函数

    new以具体类型为单位进行内存分配

    malloc以字节为单位进行内存分配

    new在申请内存空间时可进行初始化

    malloc仅根据需要申请定量的内存空间

虚函数
    构造函数不可能成为虚函数
        在构造函数执行结束后，虚函数表指针才会被正确初始化

    构造函数中不可能发生多态行为
        在构造函数执行时，虚函数表指针未被正确初始化

    析构函数可以成为虚函数
        建议在设计类时将析构函数声明为虚构函数

    析构函数中不可能发生多态行为
        在析构函数执行时，虚函数表指针已经被销毁

dynamic_cast是与继承相关的类型转换关键字
dynamic_cast要求相关的类中必须有虚函数(需要虚函数表确定对象之间是否有继承关系)

用于有直接或间接继承关系的指针(引用)之间
    指针
        转换成功：得到目标类型的指针
        转换失败：得到一个空指针

    引用
        转换成功：得到目标类型的引用
        转换失败：得到一个异常操作信息

小结：
    new/delete会触发构造函数或者析构函数的调用

    构造函数不能成为虚函数，析构函数可以成为虚函数

    构造函数和析构函数中都无法产生多态行为

    dynamic_cast是与继承相关的专用转换关键字
```

