#### 函数模板 : 00

```
定义宏代码块
    优点：代码复用，适合所有的类型
    缺点：编译器不知道宏的存在(宏定义由预处理器处理)，缺少类型检查
定义函数
    优点：真正的函数调用，编译器对类型进行检查
    缺点：根据类型重复定义函数，无法代码复用

泛型编程概念：
    不考虑具体数据类型的编程方式

函数模板
    一种特殊的函数可用不同类型进行调用
    看起来和普通函数很相似，区别是类型可被参数化

函数模板的语法规则
    -template关键字用于声明开始进行泛型编程
    -typename关键字用于声明泛型类型(1、自动推导；2、显式调用)
    template<typename T>
    void Swap(T &a, T &b)
    {
        T t = a;
        a = b;
        b = t;
    }

小结：
    函数模板是泛型编程在C++中的应用方式之一
    函数模板能够根据实参对参数类型进行推导
    函数模板支持显示的指定参数类型
    函数模板是C++中重要的代码复用方式
```

#### 函数模板 : 01

```
函数模板深入了解
    -编译器从函数模板通过具体类型产生不同的函数
    -编译器会对函数模板进行两次编译
        对模板代码本身进行编译
        对参数替换后的代码进行编译

注意事项
    函数模板本身不允许隐式类型转换
        自动推导类型时，必须严格匹配
        显式类型指定时，能够进行隐式类型转换
    对于多参数函数模板
        无法自动推导返回值类型
        可以从左向右部分指定类型参数(工程中将返回值参数作为第一个类型参数)
```

#### 函数模板 : 02

```
函数模板可以像普通函数一样被重载
    C++编译器优先考虑普通函数
    如果函数模板可以产生一个更好的匹配，那么选择模板
    可以通过空模板是参列表限定编译器匹配模板
```

#### 类模板 : 03

```
类模板
    一些类主要用于存储和组织数据元素
    类中数据组织的方式和数据元素的具体类型无关
    如：数组类，链表类，Stack类，Queue类等

C++中将模板的思想应用于类，使得类的实现不关注数据元素的具体类型，而只关注类所需要实现的功能

C++中的类模板
    以相同的方式处理不同的类型
    在类声明前使用template进行标识
    <template T>用于说明类总使用的泛指类型T
    template <typename T>
    class Operator
    {
    public:
        T op(T a, T b);
    };

类模板的工程应用
    类模板必须在头文件中定义
    类模板不能分开实现在不同的文件中
    类模板外部定义的成员函数需要加上模板<>声明

小结：
    泛型编程的思想可以应用于类
    类模板以相同的方式处理不同类型的数据
    类模板非常适用于编写数据结构相关的代码
    类模板在使用时只能显式指定类型
```

#### 类模板 : 04

```
类模板可以被特化
    指定类模板的特定特化
    部分类型参数必须显式指定
    根据类型参数分开实现类模板

类模板的特化类型
    部分特化：用特定规则约束类型参数
    完全特化：完全显式指定类型参数

注意事项：
    特化只是模板的分开实现，本质上是同一个类模板
    特化类模板的使用方式是统一的，必须显式指定每一个类型参数

重定义和特化的不同
    重定义
        一个类模板的一个新类(或者两个类模板)
        使用的时候需要考虑如何选择的问题
    特化
        以统一的方式使用类模板的特化类
        编译器自动优先选择特化类

小结：
    类模板可以定义任意多个不同的类型参数
    类模板可以被部分特化和完全特化
    特化的本质是模板的分开实现
    函数模板只支持完全特化
    工程中使用模板特化代替类(函数)重定义
```

#### 类模板 : 05

```
模板参数可以是数值型参数(非类型参数)
    template <typename T, int N>
    void func()
    {
        T a[N]; // 使用模板参数定义局部数组
    }

注意事项：模板参数是在编译阶段被处理的单元，因此，在编译阶段必须准确无误的唯一确定
    变量不能作为模板参数
    浮点数不能作为模板参数
    类对象不能作为模板参数
```

#### 模板参数 : 06

```
小结：
    模板参数可以是数值型参数
    数值型模板参数必须在编译器期间唯一确定
    数组类模板是基于数值型模板参数实现的
    数组类模板是简易的线性表数据结构
```

#### 智能指针 : 07、08

```
智能指针的意义
    现代C++开发库中最重要的类模板之一
    C++中自动内存管理的主要手段
    能够在很大程度上避开内存相关的问题

STL中的智能指针auto_ptr
    生命周期结束时，销毁指向的内存空间
    不能指向堆数组，只能指向堆对象(变量)
    一片堆空间只属于一个智能指针对象
    多个智能指针对象不能指向同一片堆空间

小结：
    智能指针C++中自动内存管理的主要手段
    智能指针在各种平台上都有不同的表现形式
    智能指针能够尽可能的避开内存相关的问题
    STL和QT中都提供了对智能指针的支持
```

#### 单例模式 : 09、10

```
单例模式是开发者最常用的设计模式之一
单例模式的应用使得一个类最多只有一个对象
可以将单例模式相关的代码抽象成类模板
需要使用单例模式的类直接使用单例类模式
```